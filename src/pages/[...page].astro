---
import PageLayout from "@/layouts/Base.astro";
import { getAllPages, getAllPosts, getPostContentByPostId, processFileBlocks } from "@/lib/notion/client";
import { extractTargetBlocks, getNavLink, getReferencesInPage, resetCurrentHeadings, resetFirstImage, setCurrentHeadings, setTrackCurrentPageId } from "@/lib/blog-helpers";
import NotionBlocks from "@/components/NotionBlocks.astro";
import type { Post } from "@/lib/interfaces";
import { siteInfo } from "@/siteInfo";
import { FULL_PREVIEW_COLLECTIONS, HIDE_UNDERSCORE_SLUGS_IN_LISTS, HOME_PAGE_SLUG, RECENT_POSTS_ON_HOME_PAGE, HOMEPAGE_COLLECTIONS, LAST_BUILD_TIME, BUILD_FOLDER_PATHS } from "@/constants";
import PostPreview from "@/components/blog/PostPreview.astro";
import PostPreviewMedium from "@/components/blog/PostPreviewMedium.astro";
import Icon from "@/components/Icon.astro";
import { buildHeadings, slugify } from "@/utils";
import TOC from "@/components/blog/TOC.astro";
import fs from "fs/promises";
import path from "path";
import superjson from "superjson";

export async function getStaticPaths() {
		const pages = await getAllPages();
		const allPosts = await getAllPosts();
    const allItems = [...pages, ...allPosts];
		const allItemsMap = Object.fromEntries(allItems.map(item => [item.PageId, item]));

		return pages.map((page) => {
				const referencesInPage = getReferencesInPage(page.PageId);
				const linkedPageIdsSet = new Set<string>();
				if (referencesInPage) {
						referencesInPage.forEach(ref => {
								if (ref.link_to_pageid) {
										linkedPageIdsSet.add(ref.link_to_pageid);
								}
								if (ref.other_pages) {
										ref.other_pages.forEach(richText => {
												if (richText.InternalHref?.PageId) {
														linkedPageIdsSet.add(richText.InternalHref.PageId);
												} else if (richText.Mention?.Page?.PageId) {
														linkedPageIdsSet.add(richText.Mention.Page.PageId);
												}
										});
								}
						});
				}
				const linkedPageIds = Array.from(linkedPageIdsSet);

				const pageLastUpdatedBeforeLastBuild =
						LAST_BUILD_TIME && page?.LastUpdatedTimeStamp
								? page.LastUpdatedTimeStamp < LAST_BUILD_TIME
								: false;

				const linkedPostsUpdated =
						!LAST_BUILD_TIME ||
						(linkedPageIds.length > 0 && linkedPageIds.some(pageId => {
								const linkedItem = allItemsMap[pageId];
								return linkedItem && linkedItem.LastUpdatedTimeStamp > LAST_BUILD_TIME;
						}));

				const shouldUseCache = pageLastUpdatedBeforeLastBuild && !linkedPostsUpdated;

				return {
						params: { page: page.Slug === HOME_PAGE_SLUG ? undefined : `/${page.Slug}` },
						props: { page, shouldUseCache, pageLastUpdatedBeforeLastBuild },
				};
		});
}

interface Props {
		page: Post;
		shouldUseCache: boolean;
		pageLastUpdatedBeforeLastBuild: boolean;
}

const { page: slug } = Astro.params;
const { page, shouldUseCache, pageLastUpdatedBeforeLastBuild } = Astro.props;

resetCurrentHeadings();

let pageFound = true;
let blocks = null;
let referencesInPage = null;
let headings = null;

if (!page) {
	console.log("Page not found");
	pageFound = false;
}

// --- HTML Cache ---
let cachedHtml = "";
// If the page was updated before the last build, try to read the cached HTML.
if (pageFound && shouldUseCache) {
		const cacheFilePath = path.join(BUILD_FOLDER_PATHS["blocksHtmlCache"], `${page.Slug}.html`);
		try {
				cachedHtml = await fs.readFile(cacheFilePath, "utf-8");
		} catch (e) {
				cachedHtml = "";
		}
}

// --- Headings Cache ---
let cachedHeadings = null;
const headingsCacheDir = BUILD_FOLDER_PATHS["headingsCache"];
const headingsCacheFile = path.join(headingsCacheDir, `${page.Slug}.json`);

if (pageFound && pageLastUpdatedBeforeLastBuild) {
	try {
		const headingsData = await fs.readFile(headingsCacheFile, "utf-8");
		cachedHeadings = superjson.parse(headingsData);
	} catch (e) {
		cachedHeadings = null;
	}
}

if (pageFound) {
		const result = await getPostContentByPostId(page);
		blocks = result.blocks;
		referencesInPage = result.referencesInPage;

		if (cachedHeadings) {
				headings = cachedHeadings;
		} else {
				headings = buildHeadings(blocks);
				try {
						await fs.writeFile(headingsCacheFile, superjson.stringify(headings), "utf-8");
				} catch (e) {
						console.error("Error saving headings cache:", e);
				}
		}
    setCurrentHeadings(headings);

    const fileAtacchedBlocks = extractTargetBlocks(["image","video","file","audio"], blocks)
        .filter((block) => {
            if (!block) {
                return false;
            }
            const imageOrVideoOrAudioOrFile = block.NImage || block.File || block.Video || block.NAudio;
            return (
                imageOrVideoOrAudioOrFile &&
                imageOrVideoOrAudioOrFile.File &&
                imageOrVideoOrAudioOrFile.File.Url
            );
        });
    await processFileBlocks(fileAtacchedBlocks);
}

let recent_posts = null;
let homepage_collections = {};

// Legacy recent posts support
if (pageFound && page.Slug === HOME_PAGE_SLUG && RECENT_POSTS_ON_HOME_PAGE) {
		const all_posts = await getAllPosts();
		recent_posts = all_posts.filter((post) => !FULL_PREVIEW_COLLECTIONS.includes(post.Collection));
		if (HIDE_UNDERSCORE_SLUGS_IN_LISTS) {
				recent_posts = recent_posts.filter((post) => !post.Slug.startsWith("_"));
		}
		recent_posts = recent_posts.slice(0, 5);
}

// New granular homepage collections system
if (pageFound && page.Slug === HOME_PAGE_SLUG && HOMEPAGE_COLLECTIONS && Object.keys(HOMEPAGE_COLLECTIONS).length > 0) {
		const all_posts = await getAllPosts();
		
		for (const [collectionName, config] of Object.entries(HOMEPAGE_COLLECTIONS)) {
				if (config.enabled) {
						let collection_posts = all_posts.filter((post) => post.Collection === collectionName);
						
						// Apply underscore filter
						if (HIDE_UNDERSCORE_SLUGS_IN_LISTS) {
								collection_posts = collection_posts.filter((post) => !post.Slug.startsWith("_"));
						}
						
						// Filter by pinned status if use-pinned is true
						if (config["use-pinned"]) {
								collection_posts = collection_posts.filter((post) => post.Pinned);
						}
						
						// Limit number of items
						if (config["max-items"]) {
								collection_posts = collection_posts.slice(0, config["max-items"]);
						}
						
						// Store the collection data
						homepage_collections[collectionName] = {
								posts: collection_posts,
								config: config
						};
				}
		}
		if (headings) {
				// Add headings for new granular collections
				Object.entries(homepage_collections).forEach(([collectionName, data]) => {
						if (data.posts && data.posts.length > 0) {
								headings.push({
										text: data.config.title,
										slug: `auto-${collectionName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`,
										depth: 1,
								});
						}
				});
				
				// Legacy recent posts heading
				if (recent_posts && recent_posts.length > 0) {
						headings.push({
								text: "Recent Posts",
								slug: "auto-recent-posts",
								depth: 1,
						});
				}
		}
}
---

{pageFound && resetFirstImage() && setTrackCurrentPageId(page.PageId) && (
		<PageLayout
				meta={{
						title: page.Title || siteInfo.title,
						description: page.Excerpt || siteInfo.description,
						ogImage: `/og-image/${page.Slug}.png`,
				}}
		>
				<div class="max-w-[1200px] sm:ml-8 print:max-w-full print:ml-0">
						<article class="break-words" data-pagefind-body>
								{shouldUseCache && cachedHtml ? (
										<div class="post-body" data-html-type="cached" set:html={cachedHtml}></div>
								) : (
										<div class="post-body" data-html-type="new">
												<NotionBlocks blocks={blocks} />
										</div>
								)}
								{headings && !!headings.length && <TOC headings={headings} />}
						</article>
				</div>
				{/* New Granular Homepage Collections */}
				{Object.entries(homepage_collections).map(([collectionName, data]) => (
					data.posts && data.posts.length > 0 && (
										<div key={collectionName} class="max-w-[708px] sm:ml-8 print:max-w-full print:ml-0">
							<a href={`#auto-${collectionName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`} id={`auto-${collectionName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`} class="inline" onclick="var fullUrl = `${window.location.origin}${window.location.pathname}#${id}`; navigator.clipboard.writeText(fullUrl);">
								<h2 class="mb-4 mt-8 text-2xl font-normal hasId">
									<strong class="font-semibold">{data.config.title}</strong>
								</h2>
							</a>
							<section aria-label={`${data.config.title} list`}>
								{data.config['display-style'] === 'medium-cards' ? (
									// Portfolio/medium card style - no gaps, collapsed borders
									<>
										<div class="portfolio-cards grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3">
											<style>
												.portfolio-cards > * {
													margin-right: -1px;
													margin-bottom: -1px;
												}
											</style>
											{data.posts.map((post) => (
												<PostPreviewMedium key={post.id} post={post} as="h3" showPin={false} />
											))}
										</div>
										<span class="mt-4 block sm:text-end">
											<a
												class="sm:hover:text-accent"
												href={getNavLink(`/collections/${slugify(collectionName)}/`)}
												data-astro-prefetch
											>
												View all {collectionName.toLowerCase()} →
											</a>
										</span>
									</>
								) : (
									// List style for work and blog
									<>
										<ul class="space-y-4 text-start">
											{data.posts.map((post) => (
												<li key={post.id} class="flex flex-col max-w-full flex-wrap gap-1.5 [&_q]:basis-full">
													<PostPreview post={post} as="h3" withDesc />
												</li>
											))}
										</ul>
										<span class="mt-4 block sm:text-end">
											<a
												class="sm:hover:text-accent"
												href={collectionName.toLowerCase() === 'blog' ? getNavLink("/posts/") : getNavLink(`/collections/${slugify(collectionName)}/`)}
												aria-label={`View all ${collectionName.toLowerCase()}`}
											>
												View all →
											</a>
										</span>
									</>
								)}
							</section>
						</div>
					)
				))}
		</PageLayout>

		<button
				id="to-top-btn"
				class="cursor-pointer z-30 fixed print:hidden bottom-20 sm:bottom-8 end-4 flex h-10 w-10 translate-y-28 items-center justify-center rounded-full border-2 border-transparent bg-zinc-200 text-3xl opacity-0 transition-all duration-300 hover:border-zinc-400 data-[show=true]:translate-y-0 data-[show=true]:opacity-100 dark:bg-zinc-700 sm:end-8 sm:h-12 sm:w-12"
				aria-label="Back to Top"
				data-show="false"
		>
				<Icon name={"to-top"} class="h-6 w-6" aria-label="Go Back to Top" stroke-linecap="round" />
		</button>

		<script>
				document.addEventListener("DOMContentLoaded", function () {
						const scrollBtn = document.getElementById("to-top-btn");
						const targetHeader = document.getElementById("main-header");
						function callback(entries) {
								entries.forEach((entry) => {
										scrollBtn.dataset.show = (!entry.isIntersecting).toString();
								});
						}
						scrollBtn.addEventListener("click", () => {
								document.documentElement.scrollTo({ top: 0, behavior: "smooth" });
						});
						const observer = new IntersectionObserver(callback);
						observer.observe(targetHeader);
				});
		</script>
)}
