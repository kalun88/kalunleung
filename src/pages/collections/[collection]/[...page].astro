---
import type { GetStaticPaths, Page } from "astro";
import PageLayout from "@/layouts/Base.astro";
import PostPreview from "@/components/blog/PostPreview.astro";
import PostPreviewFull from "@/components/blog/PostPreviewFull.astro";
import PostPreviewMedium from "@/components/blog/PostPreviewMedium.astro";
import PostPreviewNewsFeed from "@/components/blog/PostPreviewNewsFeed.astro";
import Pagination from "@/components/Paginator.astro";
import { getAllPosts, getUniqueTags, getAllTagsWithCounts } from "@/lib/notion/client";
import type { Post, SelectProperty } from "@/lib/interfaces";
import { getCollectionsWDesc, slugify } from "@/utils";
import { getNotionColorToTailwindColor } from "@/lib/style-helpers";
import { FULL_PREVIEW_COLLECTIONS, MEDIUM_PREVIEW_COLLECTIONS, NEWS_FEED_COLLECTIONS, HIDE_UNDERSCORE_SLUGS_IN_LISTS, NUMBER_OF_POSTS_PER_PAGE, LAST_BUILD_TIME } from "@/constants";
import { getNavLink, resetCurrentHeadings, resetFirstImage, getReferencesInPage } from "@/lib/blog-helpers";
import Icon from '@/components/Icon.astro';

export const getStaticPaths = (async ({ paginate }) => {
		let posts = await getAllPosts();
		if (HIDE_UNDERSCORE_SLUGS_IN_LISTS) {
				posts = posts.filter((post) => !post.Slug.startsWith("_"));
		}

		const collections = await getCollectionsWDesc();

		const allTagsWithCounts = await getAllTagsWithCounts();

		return collections.flatMap((collection) => {
				let collectionPosts = posts.filter((post) => post.Collection === collection.name);
				collectionPosts.sort((a, b) => (a.Pinned === b.Pinned ? 0 : a.Pinned ? -1 : 1));
				const uniqueTags = getUniqueTags(collectionPosts);

				const uniqueTagsWithCounts = uniqueTags.map(tag => {
					const tagWithCount = allTagsWithCounts.find(t => t.name === tag.name);
					return {
						...tag,
						count: tagWithCount ? tagWithCount.count : 0,
					};
				});

				return paginate(collectionPosts, {
						params: { collection: slugify(collection.name) },
						props: { collection: collection.name, description: collection.description, uniqueTags: uniqueTagsWithCounts },
						pageSize: NUMBER_OF_POSTS_PER_PAGE,
				});
		});
}) satisfies GetStaticPaths;

interface Props {
		page: Page<Post>;
		collection: string;
		description: string;
		uniqueTags: (SelectProperty & { count: number })[];
}

const { page, collection, description, uniqueTags } = Astro.props as Props;

// Compute caching info for each post in page.data
const allPosts = await getAllPosts();
const allPostsMap: Record<string, Post> = Object.fromEntries(allPosts.map(p => [p.PageId, p]));

const postsWithCacheInfo = page.data.map(post => {
		const referencesInPage = getReferencesInPage(post.PageId);
		const linkedPageIdsSet = new Set<string>();

		if (referencesInPage) {
				referencesInPage.forEach(ref => {
						if (ref.link_to_pageid) {
								linkedPageIdsSet.add(ref.link_to_pageid);
						}
						if (ref.other_pages) {
								ref.other_pages.forEach(richText => {
										if (richText.InternalHref?.PageId) {
												linkedPageIdsSet.add(richText.InternalHref.PageId);
										} else if (richText.Mention?.Page?.PageId) {
												linkedPageIdsSet.add(richText.Mention.Page.PageId);
										}
								});
						}
				});
		}

		const linkedPageIds = Array.from(linkedPageIdsSet);

		const postLastUpdatedBeforeLastBuild =
				LAST_BUILD_TIME && post?.LastUpdatedTimeStamp && post.LastUpdatedTimeStamp < LAST_BUILD_TIME;

		const linkedPostsUpdated =
				!LAST_BUILD_TIME ||
				(linkedPageIds.length > 0 && linkedPageIds.some(pageId => {
						const linkedPost = allPostsMap[pageId];
						return linkedPost && linkedPost.LastUpdatedTimeStamp > LAST_BUILD_TIME;
				}));

		const shouldUseCache = postLastUpdatedBeforeLastBuild && !linkedPostsUpdated;

		return { post, shouldUseCache, postLastUpdatedBeforeLastBuild };
});

const meta = {
		title: `${collection}`,
		description: description || "Read my collection of posts.",
		ogImage: "/og-image/collectionpage---" + collection + ".png",
};

const paginationProps = {
		...(page.url.prev && {
				prevUrl: { url: getNavLink(page.url.prev), text: `← Previous Posts` },
		}),
		...(page.url.next && {
				nextUrl: { url: getNavLink(page.url.next), text: `Next Posts →` },
		}),
};
---

	<PageLayout meta={meta}>
		<div class="max-w-[708px] sm:ml-8 print:max-w-full print:ml-0 mb-8">
			<h1 class="title mt-8 mb-4">{collection}</h1>
			{description && <q class="block italic mb-6 -mt-3">{description}</q>}
		</div>
		{/* manual-edit: Updated grid layout to support medium previews and news feed */}
		<div class={`grid gap-y-16 sm:ml-8 print:ml-0 ${MEDIUM_PREVIEW_COLLECTIONS.includes(collection) || NEWS_FEED_COLLECTIONS.includes(collection) ? 'grid-cols-1' : 'grid-cols-3 sm:grid-cols-4'} sm:items-start sm:gap-x-8`}>
				<section aria-label="Blog post list" class={MEDIUM_PREVIEW_COLLECTIONS.includes(collection) || NEWS_FEED_COLLECTIONS.includes(collection) ? "col-span-1 print:col-span-full" : "col-span-3 print:col-span-full"}>
						{/* News feed layout */}
						{NEWS_FEED_COLLECTIONS.includes(collection) ? (
							<div class="news-feed-container space-y-0">
								{
									resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }, index) => (
										<PostPreviewNewsFeed 
											post={post} 
											isLast={index === postsWithCacheInfo.length - 1}
										/>
									))
								}
							</div>
						) : MEDIUM_PREVIEW_COLLECTIONS.includes(collection) ? (
							<div class="portfolio-cards grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3">
								<style>
									.portfolio-cards > * {
										margin-right: -1px;
										margin-bottom: -1px;
									}
								</style>
								{
									resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }) => (
										<PostPreviewMedium post={post} as="h2" />
									))
								}
							</div>
						) : FULL_PREVIEW_COLLECTIONS.includes(collection) ? (
							<div class="full-content-feed space-y-0">
								<style>
									.full-content-feed-item:not(:last-child) {
										border-bottom: 1px solid rgb(226 232 240);
										padding-bottom: 1rem;
										margin-bottom: 1rem;
									}
									.full-content-feed-item:last-child {
										padding-bottom: 0;
									}
								</style>
								{
									resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }) => {
										resetCurrentHeadings();
										return (
											<PostPreviewFull
												post_full_preview={post}
												shouldUseCache={shouldUseCache}
												postLastUpdatedBeforeLastBuild={postLastUpdatedBeforeLastBuild}
												as="h2"
												withDesc
											/>
										);
									})
								}
							</div>
						) : (
							<ul class="space-y-4 text-start">
								{
									resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }) => (
										<li class="flex flex-col max-w-full flex-wrap gap-1.5 [&_q]:basis-full">
											<PostPreview post={post} as="h2" withDesc />
										</li>
									))
								}
							</ul>
						)}
						<Pagination {...paginationProps} />
						<Pagination {...paginationProps} />
				</section>
				{
					!!uniqueTags.length && (
						<aside class="col-span-3 sm:col-span-1 print:hidden">
							<h2 class="mb-3 flex items-center text-sm font-semibold text-accent-2">
								<Icon class="h-4 w-4 mr-1" name={"tag-multiple"} aria-hidden="true" focusable="false"/>
								Tags
							</h2>
							<ul class="flex flex-wrap gap-1">
								{uniqueTags.map((tag) => (
									<li>
										<a
											class={`inline-flex items-center px-1.5 py-0.5 rounded-full text-[10px] font-medium transition-colors hover:opacity-80 ${getNotionColorToTailwindColor(
												tag.color + "-background", true
											)}`}
											href={getNavLink("/tags/" + slugify(tag.name) + "/")}
											aria-label={`View all posts with the tag: ${tag.name}`}
										>
											{tag.name}
											<span class="ml-1 rounded-full bg-black/10 px-1 text-[9px] text-gray-700 dark:bg-white/20 dark:text-gray-300">
												{tag.count}
											</span>
										</a>
									</li>
								))}
							</ul>
							<span class="mt-2 block sm:text-end">
								<a
									class="text-xs text-accent-2 sm:hover:text-accent transition-colors"
									href={getNavLink("/tags/")}
									aria-label="View all tags"
								>
									View all →
								</a>
							</span>
						</aside>
					)
				}
		</div>
</PageLayout>
{
	FULL_PREVIEW_COLLECTIONS.includes(collection) && (
			<button
			id="to-top-btn"
			class="cursor-pointer z-30 print:hidden fixed bottom-8 end-4 flex h-10 w-10 translate-y-28 items-center justify-center rounded-full border-2 border-transparent bg-zinc-200 text-3xl opacity-0 transition-all duration-300 hover:border-zinc-400 data-[show=true]:translate-y-0 data-[show=true]:opacity-100 dark:bg-zinc-700 sm:end-8 sm:h-12 sm:w-12"
			aria-label="Back to Top"
			data-show="false"
			>
			<Icon
							name={"to-top"}
							class="h-6 w-6"
							aria-label="Go Back to Top"
							stroke-linecap="round"
						/>
		</button>
		<script>
		document.addEventListener("DOMContentLoaded", function () {
		const scrollBtn = document.getElementById("to-top-btn");
		const targetHeader = document.getElementById("main-header");

		function callback(entries) {
			entries.forEach((entry) => {
				// only show the scroll to top button when the heading is out of view
				scrollBtn.dataset.show = (!entry.isIntersecting).toString();
			});
		}

		scrollBtn.addEventListener("click", () => {
			document.documentElement.scrollTo({ top: 0, behavior: "smooth" });
		});

		const observer = new IntersectionObserver(callback);
		observer.observe(targetHeader);});
		</script>
	)
}
