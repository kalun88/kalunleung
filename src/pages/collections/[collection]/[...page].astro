---
import type { GetStaticPaths, Page } from "astro";
import PageLayout from "@/layouts/Base.astro";
import PostPreview from "@/components/blog/PostPreview.astro";
import PostPreviewFull from "@/components/blog/PostPreviewFull.astro";
import PostPreviewMedium from "@/components/blog/PostPreviewMedium.astro";
import PostPreviewNewsFeed from "@/components/blog/PostPreviewNewsFeed.astro";
import PostPreviewWide from "@/components/blog/PostPreviewWide.astro";
import Pagination from "@/components/Paginator.astro";
import { getAllPosts, getUniqueTags, getAllTagsWithCounts, processCoverImages, processFeaturedImages } from "@/lib/notion/client";
import type { Post, SelectProperty } from "@/lib/interfaces";
import { getCollectionsWDesc, slugify } from "@/utils";
import { getNotionColorToTailwindColor } from "@/lib/style-helpers";
import { FULL_PREVIEW_COLLECTIONS, MEDIUM_PREVIEW_COLLECTIONS, NEWS_FEED_COLLECTIONS, WIDE_PREVIEW_COLLECTIONS, HIDE_UNDERSCORE_SLUGS_IN_LISTS, NUMBER_OF_POSTS_PER_PAGE, LAST_BUILD_TIME } from "@/constants";
import { getNavLink, resetCurrentHeadings, resetFirstImage, getReferencesInPage } from "@/lib/blog-helpers";
import Icon from '@/components/Icon.astro';

export const getStaticPaths = (async ({ paginate }) => {
		let posts = await getAllPosts();
		if (HIDE_UNDERSCORE_SLUGS_IN_LISTS) {
				posts = posts.filter((post) => !post.Slug.startsWith("_"));
		}

		// Process cover and featured images for all posts (downloads and optimizes them)
		await processCoverImages(posts);
		await processFeaturedImages(posts);

		const collections = await getCollectionsWDesc();

		const allTagsWithCounts = await getAllTagsWithCounts();

		return collections.flatMap((collection) => {
				let collectionPosts = posts.filter((post) => post.Collection === collection.name);
				collectionPosts.sort((a, b) => (a.Pinned === b.Pinned ? 0 : a.Pinned ? -1 : 1));
				const uniqueTags = getUniqueTags(collectionPosts);

				const uniqueTagsWithCounts = uniqueTags.map(tag => {
					const tagWithCount = allTagsWithCounts.find(t => t.name === tag.name);
					return {
						...tag,
						count: tagWithCount ? tagWithCount.count : 0,
					};
				});

				return paginate(collectionPosts, {
						params: { collection: slugify(collection.name) },
						props: { collection: collection.name, description: collection.description, uniqueTags: uniqueTagsWithCounts },
						pageSize: NUMBER_OF_POSTS_PER_PAGE,
				});
		});
}) satisfies GetStaticPaths;

interface Props {
		page: Page<Post>;
		collection: string;
		description: string;
		uniqueTags: (SelectProperty & { count: number })[];
}

const { page, collection, description, uniqueTags } = Astro.props as Props;

// Compute caching info for each post in page.data
const allPosts = await getAllPosts();
const allPostsMap: Record<string, Post> = Object.fromEntries(allPosts.map(p => [p.PageId, p]));

const postsWithCacheInfo = page.data.map(post => {
		const referencesInPage = getReferencesInPage(post.PageId);
		const linkedPageIdsSet = new Set<string>();

		if (referencesInPage) {
				referencesInPage.forEach(ref => {
						if (ref.link_to_pageid) {
								linkedPageIdsSet.add(ref.link_to_pageid);
						}
						if (ref.other_pages) {
								ref.other_pages.forEach(richText => {
										if (richText.InternalHref?.PageId) {
												linkedPageIdsSet.add(richText.InternalHref.PageId);
										} else if (richText.Mention?.Page?.PageId) {
												linkedPageIdsSet.add(richText.Mention.Page.PageId);
										}
								});
						}
				});
		}

		const linkedPageIds = Array.from(linkedPageIdsSet);

		const postLastUpdatedBeforeLastBuild =
				LAST_BUILD_TIME && post?.LastUpdatedTimeStamp && post.LastUpdatedTimeStamp < LAST_BUILD_TIME;

		const linkedPostsUpdated =
				!LAST_BUILD_TIME ||
				(linkedPageIds.length > 0 && linkedPageIds.some(pageId => {
						const linkedPost = allPostsMap[pageId];
						return linkedPost && linkedPost.LastUpdatedTimeStamp > LAST_BUILD_TIME;
				}));

		const shouldUseCache = postLastUpdatedBeforeLastBuild && !linkedPostsUpdated;

		return { post, shouldUseCache, postLastUpdatedBeforeLastBuild };
});

const meta = {
		title: `${collection}`,
		description: description || "Read my collection of posts.",
		ogImage: "/og-image/collectionpage---" + collection + ".png",
};

const paginationProps = {
		...(page.url.prev && {
				prevUrl: { url: getNavLink(page.url.prev), text: `← Previous Posts` },
		}),
		...(page.url.next && {
				nextUrl: { url: getNavLink(page.url.next), text: `Next Posts →` },
		}),
};
---

		<PageLayout meta={meta}>
			<div class="max-w-none sm:max-w-[98vw] lg:max-w-[96vw] xl:max-w-[1600px] sm:ml-8 print:ml-0 print:max-w-full mb-8">
			<h1 class="title mt-8 mb-4">{collection}</h1>
			{description && <q class="block italic mb-6 -mt-3">{description}</q>}
		</div>
		{/* manual-edit: Updated grid layout to support medium previews and news feed with sidebar */}
		<div class="grid grid-cols-3 sm:grid-cols-4 gap-y-16 sm:ml-8 print:ml-0 max-w-none sm:max-w-[98vw] lg:max-w-[96vw] xl:max-w-[1500px] print:max-w-full sm:items-start sm:gap-x-8">
				<section aria-label="Blog post list" class="col-span-3 print:col-span-full">
							{/* News feed layout */}
							{NEWS_FEED_COLLECTIONS.includes(collection) ? (
								<div class="news-feed-container space-y-0 max-w-none sm:max-w-[90vw] lg:max-w-[85vw] xl:max-w-[1200px]">
									{
										resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }, index) => (
											<PostPreviewNewsFeed 
												post={post} 
												isLast={index === postsWithCacheInfo.length - 1}
											/>
										))
									}
								</div>
							) : MEDIUM_PREVIEW_COLLECTIONS.includes(collection) ? (
								<div class="portfolio-cards grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 max-w-none sm:max-w-[90vw] lg:max-w-[85vw] xl:max-w-[1100px]">
									{
										resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }) => (
											<PostPreviewMedium post={post} as="h2" />
										))
									}
								</div>
							) : WIDE_PREVIEW_COLLECTIONS.includes(collection) ? (
								<div class="wide-feed-container space-y-0 max-w-none sm:max-w-[90vw] lg:max-w-[85vw] xl:max-w-[1200px]">
									{
										resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }) => (
											<PostPreviewWide post={post} as="h2" />
										))
									}
								</div>
							) : FULL_PREVIEW_COLLECTIONS.includes(collection) ? (
								<div class="full-content-feed space-y-0 max-w-none sm:max-w-[90vw] lg:max-w-[85vw] xl:max-w-[1100px]">
									<style>
										.full-content-feed-item:not(:last-child) {
											border-bottom: 1px solid rgb(226 232 240);
											padding-bottom: 1rem;
											margin-bottom: 1rem;
										}
										.full-content-feed-item:last-child {
											padding-bottom: 0;
										}
									</style>
									{
										resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }) => {
											resetCurrentHeadings();
											return (
												<PostPreviewFull
													post_full_preview={post}
													shouldUseCache={shouldUseCache}
													postLastUpdatedBeforeLastBuild={postLastUpdatedBeforeLastBuild}
													as="h2"
													withDesc
												/>
											);
										})
									}
								</div>
							) : (
								<ul class="space-y-4 text-start">
									{
										resetFirstImage() && postsWithCacheInfo.map(({ post, shouldUseCache, postLastUpdatedBeforeLastBuild }) => (
											<li class="flex flex-col max-w-full flex-wrap gap-1.5 [&_q]:basis-full">
												<PostPreview post={post} as="h2" withDesc />
											</li>
										))
									}
								</ul>
							)}
						<Pagination {...paginationProps} />
						<Pagination {...paginationProps} />
				</section>
				{
					!!uniqueTags.length && (
						<aside class="col-span-3 sm:col-span-1 print:hidden">
							<h2 class="mb-3 flex items-center text-sm font-semibold text-accent-2">
								<Icon class="h-4 w-4 mr-1" name={"tag-multiple"} aria-hidden="true" focusable="false"/>
								Tags
							</h2>
							<ul class="flex flex-col gap-1 font-mono text-xs">
								{uniqueTags.map((tag) => (
									<li class="flex items-center">
										<a
											class="inline-flex items-center transition-opacity hover:opacity-80"
											href={getNavLink("/tags/" + slugify(tag.name) + "/")}
											aria-label={`View all posts with the tag: ${tag.name}`}
										>
											[{tag.name}]
										</a>
										<span class="ml-1 text-[10px] text-gray-500">
											{tag.count}
										</span>
									</li>
								))}
							</ul>
							<div class="mt-2">
								<a
									class="text-xs text-accent-2 sm:hover:text-accent transition-colors"
									href={getNavLink("/tags/")}
									aria-label="View all tags"
								>
									View all →
								</a>
							</div>
						</aside>
					)
				}
		</div>
</PageLayout>
{
	FULL_PREVIEW_COLLECTIONS.includes(collection) && (
			<button
			id="to-top-btn"
			class="cursor-pointer z-30 print:hidden fixed bottom-8 end-4 flex h-10 w-10 translate-y-28 items-center justify-center rounded-full border-2 border-transparent bg-zinc-200 text-3xl opacity-0 transition-all duration-300 hover:border-zinc-400 data-[show=true]:translate-y-0 data-[show=true]:opacity-100 dark:bg-zinc-700 sm:end-8 sm:h-12 sm:w-12"
			aria-label="Back to Top"
			data-show="false"
			>
			<Icon
							name={"to-top"}
							class="h-6 w-6"
							aria-label="Go Back to Top"
							stroke-linecap="round"
						/>
		</button>
		<script>
		document.addEventListener("DOMContentLoaded", function () {
		const scrollBtn = document.getElementById("to-top-btn");
		const targetHeader = document.getElementById("main-header");

		function callback(entries) {
			entries.forEach((entry) => {
				// only show the scroll to top button when the heading is out of view
				scrollBtn.dataset.show = (!entry.isIntersecting).toString();
			});
		}

		scrollBtn.addEventListener("click", () => {
			document.documentElement.scrollTo({ top: 0, behavior: "smooth" });
		});

		const observer = new IntersectionObserver(callback);
		observer.observe(targetHeader);});
		</script>
	)
}
